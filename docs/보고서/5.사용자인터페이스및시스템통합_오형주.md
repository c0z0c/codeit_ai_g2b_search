## RAG 기반 PEP 문서 처리 시스템: 사용자 인터페이스 및 시스템 통합 보고서 (오형주)

-----

### 5\. 사용자 인터페이스 및 시스템 통합

본 보고서는 RAG(Retrieval-Augmented Generation) 기반 PEP(공공데이터 포털) 문서 처리 시스템의 **사용자 인터페이스(UI)** 설계 및 **시스템 통합(System Integration)** 아키텍처에 대해 상세히 기술합니다.

#### 5.1. Streamlit 기반 UI 설계

Streamlit은 데이터 과학 애플리케이션을 위한 Python 기반 오픈소스 프레임워크로, **개발 생산성** 극대화 및 사용자에게 **직관적인 인터페이스** 제공을 위해 채택되었습니다.

##### 5.1.1. 페이지 구조 및 레이아웃

시스템의 페이지 구조는 **단일 페이지(Single Page)** 형태로 설계되었으며, 효율적인 정보 접근을 위해 \*\*사이드바(Sidebar)\*\*와 \*\*메인 영역(Main Area)\*\*으로 구성됩니다.

  * **제목 및 식별**: `set_page_config` 메서드를 통해 시스템 제목이 브라우저 탭에 명확히 표시됩니다.
  * **사이드바**: 주요 **설정** 및 **제어 기능** (세션 관리, 검색 옵션, 고급 설정 등)을 담당하며, 메인 화면의 집중도를 높입니다.
  * **메인 영역**: **채팅 인터페이스**로 구성되어, 사용자 메시지와 어시스턴트 응답을 시간순으로 표시합니다. `chat_message` 컴포넌트를 사용하여 역할(role)별 스타일을 구분합니다.
  * **입력 영역**: 화면 하단에 고정된 `chat_input` 컴포넌트를 통해 텍스트 입력 기능을 제공합니다.
  * **반응형 디자인**: Streamlit 기본 기능을 활용하여 모바일 환경에서도 사용 가능한 레이아웃을 유지합니다.

##### 5.1.2. 채팅 인터페이스 구현

자연스러운 대화 경험을 제공하기 위해 다음과 같은 UX 패턴이 적용되었습니다.

  * **메시지 표시 및 상태 유지**: \*\*`session_state`\*\*를 활용하여 대화 이력(`messages` 리스트)을 저장 및 유지하고, 페이지 렌더링 시 이를 순회하며 표시합니다.
  * **스트리밍 응답 (Streaming Response)**: LLM(Large Language Model)이 답변을 생성하는 즉시**`OpenAI API의 스트리밍(Streaming) 기능을 활용하여`** 사용자 질문에 대한 응답을 실시간으로 생성합니다.
  * **로딩 인디케이터 (Loading Indicator)**: 검색 및 응답 생성 중에는 `spinner` 컴포넌트를 사용하여 시스템이 작동 중임을 명확히 알립니다.
  * **에러 처리 (Error Handling)**: `error` 컴포넌트를 통해 사용자 친화적인 오류 메시지를 표시하며, 기술적 세부사항을 숨기고 구체적인 해결 방법을 안내합니다.
  * **자동 스크롤**: 새로운 메시지 추가 시 화면이 자동으로 최하단으로 스크롤되어 최신 메시지 확인을 용이하게 합니다.
  * **메시지 컨텍스트 메뉴**: 메시지 옆에 아이콘 버튼을 배치하여 **출처 보기** 등의 추가 액션을 제공하여 답변의 **신뢰성**을 높입니다.

##### 5.1.3. 세션 관리 UI

사용자가 여러 대화를 조직하고 관리할 수 있도록 사이드바에 세션 관리 섹션을 할당했습니다.

  * **새 세션 생성**: 버튼 클릭 시 새로운 세션 ID가 생성되고 `session_state`가 초기화되어 새로운 대화를 시작할 수 있습니다.
  * **세션 목록**: `expander` 컴포넌트로 구현되며, 각 세션의 이름, 마지막 활동 시각 등의 정보와 함께 표시됩니다.
  * **세션 전환**: 선택 시 `ChatHistoryDB`에서 해당 세션의 메시지를 불러와 화면에 표시하며, 현재 세션의 상태는 자동으로 저장됩니다.
  * **세션 삭제**: 확인 대화상자를 표시하여 실수로 인한 데이터 손실을 방지합니다.
  * **활성 세션 표시**: 현재 활성화된 세션을 하이라이트 색상과 아이콘으로 시각적으로 구분합니다.
  * **세션 통계**: `ChatHistoryDB`의 `get_chat_stats` 메서드를 호출하여 총 대화 수, 메시지 수 등의 통계를 사이드바 하단에 제공합니다.

-----

### 5.2. 시스템 통합 아키텍처

#### 5.2.1. 모듈 간 데이터 흐름

시스템은 독립적인 모듈들이 명확한 인터페이스를 통해 통신하는 구조입니다.

**사용자 질의 응답 흐름:**

1.  **사용자 질문** (**Streamlit UI** 입력) $\rightarrow$ `app.py` 이벤트 핸들러 수신.
2.  **`Retrieval` 모듈 호출**: 질의 텍스트를 전달하여 관련 문서 검색을 수행.
3.  **`Retrieval`** $\rightarrow$ **`VectorStoreManager`** 호출: FAISS 인덱스에서 유사도 검색 실행 후, **상위 k개 청크**를 텍스트 및 메타데이터(파일명, 페이지 번호 등)와 함께 딕셔너리 형태로 반환.
4.  **`LLMProcessor` 호출**: 검색 결과 청크를 프롬프트 컨텍스트로 포맷하고 사용자 질의와 함께 LLM에 전달.
5.  **`LLMProcessor`** $\rightarrow$ **OpenAI API** 호출: 응답 생성.
6.  **`LLMProcessor`** $\rightarrow$ **`ChatHistoryDB`** 호출: 질의와 응답(검색 청크 정보 포함)을 기록.
7.  \*\*`app.py`\*\*로 답변 반환 $\rightarrow$ **Streamlit UI**를 통해 사용자에게 표시 (스트리밍 또는 일괄).

**데이터 변환 및 에러 전파**:

  * **데이터 변환 (Data Transformation)**: 모듈 경계에서 발생하며, 예를 들어 `Retrieval`의 출력(딕셔너리 리스트)은 `LLMProcessor`에서 문자열 형태의 컨텍스트로 변환됩니다.
  * **에러 전파 (Error Propagation)**: 하위 모듈에서 발생한 예외는 로깅 후 상위 모듈로 전파되며, `app.py`에서 최종적으로 포착되어 사용자 친화적인 오류 메시지로 변환됩니다.

#### 5.2.2. Config 기반 설정 관리

시스템의 모든 설정은 **Config 클래스**를 통해 중앙 집중식으로 관리됩니다.

  * **Config 클래스**: \*\*싱글톤 패턴(Singleton Pattern)\*\*으로 구현되어 애플리케이션 전체에서 동일한 인스턴스를 공유하며, 설정의 **일관성**과 **메모리 효율성**을 보장합니다.
  * **설정 파일**: 가독성과 편집 용이성을 위해 **JSON 형식**을 사용하며, 설정이 누락되거나 파일이 없을 경우 클래스 내부에 정의된 **기본값**을 사용합니다.
  * **동적 설정 변경**: `top_k`, `temperature` 등 일부 설정은 UI를 통해 **런타임**에 동적으로 조정 가능하며, 즉시 다음 질의부터 적용됩니다.
  * **환경 변수 오버라이드**: OpenAI API 키와 같은 민감 정보는 환경 변수를 우선적으로 확인하여 보안을 강화하고 배포 환경의 유연성을 확보합니다.
  * **설정 검증**: 애플리케이션 시작 시 필수 설정 누락 및 값의 유효성을 검증하여 런타임 에러를 사전에 방지합니다.

#### 5.2.3. 로깅 및 모니터링

포괄적인 로깅 체계를 통해 시스템 동작 추적 및 문제 진단을 용이하게 합니다.

  * **로그 레벨**: **DEBUG, INFO, WARNING, ERROR, CRITICAL** 5단계로 구분하여 중요도에 따라 필터링합니다.
  * **로그 포맷**: 타임스탬프(KST 타임존), 로그 레벨, 모듈명, 함수명, 메시지로 구성된 **일관된 구조**를 사용합니다.
  * **파일 로깅**: \*\*`RotatingFileHandler`\*\*를 사용하여 로그 파일이 일정 크기를 초과하면 자동으로 회전(rotation)하며, `logs/` 디렉토리에 날짜별로 저장됩니다.
  * **콘솔 로깅**: 개발 환경에서 \*\*`StreamHandler`\*\*를 통해 실시간 피드백을 제공하며, 색상 코딩을 적용하여 레벨을 시각적으로 구분합니다.
  * **성능 로깅**: 검색, 임베딩, LLM 응답 생성 등 주요 작업의 **실행 시간**을 측정 및 기록하여 성능 병목 지점을 식별합니다.
  * **에러 로깅**: `logging.exception` 메서드를 사용하여 **스택 트레이스**를 포함한 전체 예외 정보를 상세히 기록합니다.

-----

### 5.3. 추가 기능

#### 5.3.1. Top-K 파라미터 조정

검색 결과로 반환할 \*\*청크의 개수($k$)\*\*를 지정하는 파라미터로, 검색 품질과 응답 생성 비용의 균형을 조정합니다.

$$
\text{Top-K} = k \quad (1 \le k \le 20)
$$

#### 5.3.2. 문서 업로드 및 인덱싱

사용자가 직접 PDF 문서를 시스템에 추가하고 분석할 수 있는 기능을 제공합니다.

  * **파일 업로더**: Streamlit의 `file_uploader` 컴포넌트를 사용하여 PDF 파일만 허용하며, `UploadedFile` 객체로 반환됩니다.
  * **중복 검사**: 파일 내용의 **SHA-256 해시**를 계산하여 `DocumentsDB`에서 중복 여부를 즉시 확인하고, 중복 시 업로드를 중단합니다.
  * **문서 처리 파이프라인**: 업로드 후 PDF 파싱, 전처리, `DocumentsDB` 저장, 임베딩 생성($\rightarrow$ **FAISS Index** 추가)의 전 과정이 순차적으로 실행되며, `progress` 컴포넌트로 진행 상황을 표시합니다.
  * **임베딩 생성 선택**: 문서를 DB에 저장한 후 **즉시 임베딩 생성**할지, **나중에 배치 작업**으로 수행할지 선택할 수 있습니다.
  * **오류 처리**: 파일 손상, 파싱 실패, API 호출 실패 등의 문제가 발생하면 명확한 오류 메시지를 표시하고, 부분 처리된 데이터는 롤백하여 데이터베이스 일관성을 유지합니다.

#### 5.3.3. 공공데이터 포털 업데이트

  * **시작날짜/종료날짜**: 사용자가 입력한 정보를 수집할 시작과 종료 날짜를 기반으로 document.db를 업데이트하여 저장합니다.
  * **중복 검사**: 파일 내용의 **SHA-256 해시**를 계산하여 `DocumentsDB`에서 중복 여부를 즉시 확인하고, 중복 시 업로드를 중단합니다.
  * **문서 처리 파이프라인**: 업로드 후 PDF 파싱, 전처리, `DocumentsDB` 저장, 임베딩 생성($\rightarrow$ **FAISS Index** 추가)의 전 과정이 순차적으로 실행되며, `progress` 컴포넌트로 진행 상황을 표시합니다.
  * **임베딩 생성 선택**: 문서를 DB에 저장한 후 **즉시 임베딩 생성**할지, **나중에 배치 작업**으로 수행할지 선택할 수 있습니다.
  * **오류 처리**: 파일 손상, 파싱 실패, API 호출 실패 등의 문제가 발생하면 명확한 오류 메시지를 표시하고, 부분 처리된 데이터는 롤백하여 데이터베이스 일관성을 유지합니다.

#### 5.3.4. 검색 결과 시각화

검색 결과를 시각적으로 풍부하게 제공하여 사용자의 결과 이해 및 탐색을 돕습니다.

  * **청크 카드**: `expander`를 사용하여 각 검색 결과를 접을 수 있는 카드 형태로 표현하며, 헤더에는 **문서명, 페이지 번호, 유사도 점수**를 표시합니다. 펼치면 청크 텍스트가 나타나고, 질의와 일치하는 키워드는 하이라이트됩니다.
  * **유사도 점수 시각화**: 각 청크의 유사도를 0에서 1로 **정규화**하고, 색상 막대 그래프로 표현하여 결과 품질을 직관적으로 파악할 수 있습니다.
  * **문서 분포 차트**: 파이 차트나 막대 차트를 사용하여 검색 결과가 어떤 문서에서 왔는지 시각화하고, 특정 문서를 클릭하여 필터링할 수 있습니다.
